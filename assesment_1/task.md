Реализация многопользовательской системы чтения/записи с кешированием 

## Условия задачи

Компоненты системы:

1. **Каналы для записи сообщений**: Несколько пользователей передают изменения для записи в файлы через каналы.
1.1 Пользователей можно сэмулировать обычным циклом
2. **Кеширование сообщений**: Сообщения из каналов кешируются.
3. **Воркер**: Воркер проходит по кешу и каждые секунду записывает изменения в соответствующие файлы.
4. **Валидация токенов**: Если сообщение приходит от пользователя с неправильным токеном, оно не должно быть записано.
5. **Graceful Shutdown**. При остановке приложения все закешированные данные должны записаться в файл

## Требования

1. **Структура данных для сообщений**:
   - Каждое сообщение должно содержать идентификатор пользователя, токен, идентификатор файла и данные для записи.
   - Пример структуры для сообщения:
     ```go
     type Message struct {
       Token     string
       FileID    string
       Data      string
     }
     ```

2. **Кеширование сообщений**:
   - Реализуйте обработчик, который будет вычитывать данные из каналов и помещать их в кеш, если токен пользователя валидный.
   - Используйте map для хранения сообщений в кеше. Ключом служит идентификатор файла, а значением список сообщений.

3. **Валидация токенов**:
   - Создайте функцию или метод для проверки токенов пользователей. Храните допустимые токены(white-list) в специальной структуре

4. **Воркер для записи данных в файлы**:
   - Воркер должен периодически (раз в секунду и задается с конфига) проходить по кешу и записывать все изменения в соответствующие файлы.
   - После записи кеш для этих файлов должен быть очищен.


## Cхема

![](./schema.png "Schema")
